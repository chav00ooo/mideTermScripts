import socket
import nmap
import csv
import json
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
import os

# Configuration: Define the targets and the port range to scan
TARGETS = ["127.0.0.1", "scanme.nmap.org"]  # List of authorized targets
PORT_RANGE = range(0, 1025)  # Port range to scan (0-1025 includes all common ports)

def scan_port(ip, port):
    """
    Scans a single port on the target IP to check if it is open.
    Args:
        ip (str): Target IP address.
        port (int): Port number to scan.
    Returns:
        int or None: Returns the port number if open, None otherwise.
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(0.5)  # Timeout set to 0.5 seconds for faster scans
            if s.connect_ex((ip, port)) == 0:  # Successful connection indicates the port is open
                print(f"[{datetime.now()}] Port {port} is open on {ip}")
                return port
    except Exception:
        pass  # Ignore any exceptions and move on to the next port
    return None

def scan_ports(ip, ports):
    """
    Scans multiple ports on a target IP address using multithreading.
    Args:
        ip (str): Target IP address.
        ports (range): Range of ports to scan.
    Returns:
        list: List of open ports.
    """
    open_ports = []
    # Use ThreadPoolExecutor to scan multiple ports concurrently
    with ThreadPoolExecutor(max_workers=10) as executor:
        results = executor.map(lambda port: scan_port(ip, port), ports)
        open_ports = [port for port in results if port]  # Collect only open ports
    return open_ports

def detect_services(ip, ports):
    """
    Uses Nmap to detect services and versions running on open ports.
    Args:
        ip (str): Target IP address.
        ports (list): List of open ports to scan for services.
    Returns:
        dict: A dictionary mapping ports to their detected services and versions.
    """
    nm = nmap.PortScanner()  # Initialize the Nmap scanner
    results = {}
    for port in ports:
        print(f"[{datetime.now()}] Detecting service on port {port}...")
        nm.scan(ip, str(port), arguments='-sV --host-timeout 10s')  # Perform service detection with a 10-second timeout
        try:
            # Extract the service name and version for the port
            service = nm[ip]['tcp'][port]['name']
            version = nm[ip]['tcp'][port].get('version', 'Unknown')
            results[port] = {"service": service, "version": version}
        except KeyError:
            # If no service is detected, return 'Unknown' for both
            results[port] = {"service": "Unknown", "version": "Unknown"}
    return results

def match_vulnerabilities(port, service):
    """
    Matches the detected ports and services to known vulnerabilities in the database.
    Args:
        port (int): Port number.
        service (str): Detected service name.
    Returns:
        list: List of vulnerabilities associated with the port or service.
    """
    db_path = os.path.join(os.path.dirname(__file__), "vulnerability_db.json")
    try:
        with open(db_path, "r", encoding="utf-8") as file:
            vuln_db = json.load(file)  # Load the vulnerability database
        # Match vulnerabilities for the port and the service
        vulnerabilities = vuln_db.get(str(port), []) + vuln_db.get(service, [])
        return vulnerabilities
    except FileNotFoundError:
        print(f"[{datetime.now()}] Error: Vulnerability database not found at {db_path}")
        return []
    except json.JSONDecodeError:
        print(f"[{datetime.now()}] Error: Vulnerability database is not in valid JSON format.")
        return []

def save_results_to_csv(results, filename="vulnerability_report.csv"):
    """
    Saves the scan results to a CSV file for further analysis.
    Args:
        results (list): List of dictionaries containing scan results.
        filename (str): Name of the output CSV file.
    """
    if not results:
        print(f"[{datetime.now()}] No results to save. Skipping CSV creation.")
        return
    print(f"[{datetime.now()}] Saving results to {filename}...")
    with open(filename, mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["Target", "Port", "Service", "Version", "Vulnerabilities"])  # Header row
        for result in results:
            writer.writerow([
                result["target"],
                result["port"],
                result["service"],
                result["version"],
                ", ".join(result["vulnerabilities"])
            ])
    print(f"[{datetime.now()}] Results saved successfully to {filename}.")

# Main Script
if __name__ == "__main__":
    print(f"[{datetime.now()}] Starting vulnerability scan")
    all_results = []

    for target in TARGETS:
        print(f"\n[{datetime.now()}] Scanning target: {target}")
        
        # Step 1: Scan for open ports
        open_ports = scan_ports(target, PORT_RANGE)
        print(f"[{datetime.now()}] Open ports on {target}: {open_ports}")
        
        # Step 2: Detect services running on open ports
        services = detect_services(target, open_ports)
        for port, details in services.items():
            print(f"[{datetime.now()}] Port {port}: Service - {details['service']}, Version - {details['version']}")
        
        # Step 3: Match services and ports to known vulnerabilities
        for port, details in services.items():
            vulnerabilities = match_vulnerabilities(port, details["service"])
            all_results.append({
                "target": target,
                "port": port,
                "service": details["service"],
                "version": details["version"],
                "vulnerabilities": vulnerabilities
            })

    # Step 4: Save results to a CSV file
    save_results_to_csv(all_results)
    print(f"[{datetime.now()}] Scan complete. Results saved to 'vulnerability_report.csv'.")
